<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Classical Ciphers Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      background: #f2f2f2;
    }
    h2 {
      text-align: center;
    }
    .container {
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      max-width: 700px;
      margin: auto;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    label {
      font-weight: bold;
    }
    input, textarea, select, button {
      width: 100%;
      padding: 10px;
      margin: 8px 0;
      border-radius: 5px;
      border: 1px solid #ccc;
    }
    button {
      background: #007BFF;
      color: white;
      border: none;
      cursor: pointer;
    }
    button:hover {
      background: #0056b3;
    }
  </style>
</head>
<body>
  <h2>Các phương pháp mã hóa cổ điển</h2>
  <div class="container">
    <label for="cipher">Chọn thuật toán:</label>
    <select id="cipher" onchange="renderParams()">
      <option value="caesar">Caesar</option>
      <option value="affine">Affine</option>
      <option value="vigenere">Vigenère</option>
      <option value="playfair">Playfair</option>
      <option value="columnar">Hoán vị (Columnar)</option>
    </select>

    <div id="params"></div>

    <label for="input">Văn bản gốc:</label>
    <textarea id="input" rows="4"></textarea>

    <button onclick="doEncrypt()">Mã hóa</button>
    <button onclick="doDecrypt()">Giải mã</button>

    <h3>Kết quả:</h3>
    <textarea id="output" rows="4" readonly></textarea>
  </div>

  <script>
    const cipherSel = document.getElementById("cipher");
    const params = document.getElementById("params");
    const input = document.getElementById("input");
    const output = document.getElementById("output");

    function renderParams() {
      const c = cipherSel.value;
      params.innerHTML = "";
      if (c === "caesar") {
        params.innerHTML = '<label>Khóa k (0-25):</label><input id="param_k" type="number" value="3" min="0" max="25">';
      } else if (c === "affine") {
        params.innerHTML = '<label>a (nguyên tố cùng nhau với 26):</label><input id="param_a" type="number" value="5">'
                         + '<label>b (0-25):</label><input id="param_b" type="number" value="8">';
      } else if (c === "vigenere") {
        params.innerHTML = '<label>Khóa:</label><input id="param_key" type="text" value="LEMON">';
      } else if (c === "playfair") {
        params.innerHTML = '<label>Khóa:</label><input id="param_key" type="text" value="PLAYFAIR">';
      } else if (c === "columnar") {
        params.innerHTML = '<label>Khóa (chuỗi hoán vị):</label><input id="param_key" type="text" value="3142">';
      }
    }
    renderParams();

    /* ================= Algorithms ================= */
    // Caesar
    function caesarCipher(str, shift) {
      let res = "";
      for (let i = 0; i < str.length; i++) {
        let ch = str[i];
        let code = str.charCodeAt(i);
        if (code >= 65 && code <= 90) {
          ch = String.fromCharCode(((code - 65 + shift) % 26 + 26) % 26 + 65);
        } else if (code >= 97 && code <= 122) {
          ch = String.fromCharCode(((code - 97 + shift) % 26 + 26) % 26 + 97);
        }
        res += ch;
      }
      return res;
    }

    // Affine
    function affine_encrypt(text, a, b) {
      let res = "";
      for (let c of text) {
        let code = c.charCodeAt(0);
        if (c.match(/[A-Za-z]/)) {
          let base = c === c.toUpperCase() ? 65 : 97;
          res += String.fromCharCode(((a * (code - base) + b) % 26) + base);
        } else res += c;
      }
      return res;
    }
    function modInverse(a, m) {
      a = ((a % m) + m) % m;
      for (let x = 1; x < m; x++) if ((a * x) % m === 1) return x;
      return 1;
    }
    function affine_decrypt(text, a, b) {
      let res = "";
      let inv = modInverse(a, 26);
      for (let c of text) {
        let code = c.charCodeAt(0);
        if (c.match(/[A-Za-z]/)) {
          let base = c === c.toUpperCase() ? 65 : 97;
          res += String.fromCharCode(((inv * (code - base - b + 26)) % 26) + base);
        } else res += c;
      }
      return res;
    }

    // Vigenère
    function vigenere_encrypt(text, key) {
      let res = "";
      key = key.toUpperCase();
      let j = 0;
      for (let i = 0; i < text.length; i++) {
        let c = text[i];
        if (/[A-Za-z]/.test(c)) {
          let base = c === c.toUpperCase() ? 65 : 97;
          let k = key.charCodeAt(j % key.length) - 65;
          res += String.fromCharCode((c.charCodeAt(0) - base + k) % 26 + base);
          j++;
        } else res += c;
      }
      return res;
    }
    function vigenere_decrypt(text, key) {
      let res = "";
      key = key.toUpperCase();
      let j = 0;
      for (let i = 0; i < text.length; i++) {
        let c = text[i];
        if (/[A-Za-z]/.test(c)) {
          let base = c === c.toUpperCase() ? 65 : 97;
          let k = key.charCodeAt(j % key.length) - 65;
          res += String.fromCharCode((c.charCodeAt(0) - base - k + 26) % 26 + base);
          j++;
        } else res += c;
      }
      return res;
    }

    // Playfair
    function generatePlayfairMatrix(key) {
      key = key.toUpperCase().replace(/J/g, "I");
      let set = "";
      for (let c of key + "ABCDEFGHIKLMNOPQRSTUVWXYZ") {
        if (!set.includes(c)) set += c;
      }
      let mat = [];
      for (let i = 0; i < 5; i++) mat.push(set.slice(i*5, i*5+5).split(""));
      return mat;
    }
    function findPos(mat, ch) {
      for (let i=0;i<5;i++) for (let j=0;j<5;j++) if (mat[i][j]===ch) return [i,j];
    }
    function playfair_preprocess(text) {
      text = text.toUpperCase().replace(/J/g, "I").replace(/[^A-Z]/g,"");
      let res = "";
      for (let i=0;i<text.length;i++) {
        res += text[i];
        if (i<text.length-1 && text[i]===text[i+1]) res += "X";
      }
      if (res.length % 2) res += "X";
      return res;
    }
    function playfair_encrypt(text,key) {
      let mat = generatePlayfairMatrix(key);
      text = playfair_preprocess(text);
      let res = "";
      for (let i=0;i<text.length;i+=2) {
        let a=findPos(mat,text[i]), b=findPos(mat,text[i+1]);
        if (a[0]===b[0]) {
          res+=mat[a[0]][(a[1]+1)%5];
          res+=mat[b[0]][(b[1]+1)%5];
        } else if (a[1]===b[1]) {
          res+=mat[(a[0]+1)%5][a[1]];
          res+=mat[(b[0]+1)%5][b[1]];
        } else {
          res+=mat[a[0]][b[1]];
          res+=mat[b[0]][a[1]];
        }
      }
      return res;
    }
    function playfair_decrypt(text,key) {
      let mat = generatePlayfairMatrix(key);
      text = text.toUpperCase().replace(/J/g,"I").replace(/[^A-Z]/g,"");
      let res = "";
      for (let i=0;i<text.length;i+=2) {
        let a=findPos(mat,text[i]), b=findPos(mat,text[i+1]);
        if (a[0]===b[0]) {
          res+=mat[a[0]][(a[1]+4)%5];
          res+=mat[b[0]][(b[1]+4)%5];
        } else if (a[1]===b[1]) {
          res+=mat[(a[0]+4)%5][a[1]];
          res+=mat[(b[0]+4)%5][b[1]];
        } else {
          res+=mat[a[0]][b[1]];
          res+=mat[b[0]][a[1]];
        }
      }
      return res;
    }

    // Columnar
    function columnar_encrypt(text,key) {
      let n=key.length;
      let order=key.split("").map((c,i)=>[c,i]).sort().map(x=>x[1]);
      text=text.replace(/ /g,"");
      while(text.length % n) text+="X";
      let rows=[];
      for(let i=0;i<text.length;i+=n) rows.push(text.slice(i,i+n));
      let res="";
      for(let idx of order) for(let row of rows) res+=row[idx];
      return res;
    }
    function columnar_decrypt(text,key) {
      let n=key.length;
      let order=key.split("").map((c,i)=>[c,i]).sort().map(x=>x[1]);
      let m=text.length/n;
      let cols=Array(n).fill("");
      let k=0;
      for(let idx of order) {
        cols[idx]=text.slice(k,k+m);
        k+=m;
      }
      let res="";
      for(let i=0;i<m;i++) for(let j=0;j<n;j++) res+=cols[j][i];
      return res;
    }

    /* ================= UI Functions ================= */
    function doEncrypt() {
      let c = cipherSel.value;
      let text = input.value;
      let result = "";
      if (c === "caesar") {
        let k = parseInt(document.getElementById("param_k").value);
        result = caesarCipher(text, k);
      } else if (c === "affine") {
        let a = parseInt(document.getElementById("param_a").value);
        let b = parseInt(document.getElementById("param_b").value);
        result = affine_encrypt(text, a, b);
      } else if (c === "vigenere") {
        let key = document.getElementById("param_key").value;
        result = vigenere_encrypt(text, key);
      } else if (c === "playfair") {
        let key = document.getElementById("param_key").value;
        result = playfair_encrypt(text, key);
      } else if (c === "columnar") {
        let key = document.getElementById("param_key").value;
        result = columnar_encrypt(text, key);
      }
      output.value = result;
    }
    function doDecrypt() {
      let c = cipherSel.value;
      let text = input.value;
      let result = "";
      if (c === "caesar") {
        let k = parseInt(document.getElementById("param_k").value);
        result = caesarCipher(text, -k);
      } else if (c === "affine") {
        let a = parseInt(document.getElementById("param_a").value);
        let b = parseInt(document.getElementById("param_b").value);
        result = affine_decrypt(text, a, b);
      } else if (c === "vigenere") {
        let key = document.getElementById("param_key").value;
        result = vigenere_decrypt(text, key);
      } else if (c === "playfair") {
        let key = document.getElementById("param_key").value;
        result = playfair_decrypt(text, key);
      } else if (c === "columnar") {
        let key = document.getElementById("param_key").value;
        result = columnar_decrypt(text, key);
      }
      output.value = result;
    }
  </script>
</body>
</html>
